<!doctype html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ConnectNow â€” 1:1 Video (Fixed)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{--bg:#0b0f13;--card:#0f1720;--muted:#94a3b8;--accent:#22c55e}
    body{background:var(--bg);color:#e6eef8;font-family:Inter,system-ui,Arial}
    .small-video{width:110px;height:80px;object-fit:cover;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.6)}
    .btn{padding:.5rem 1rem;border-radius:.5rem}
    #enableSound { position: fixed; right: 16px; bottom: 100px; z-index: 60; display:none; }
  </style>
</head>
<body class="min-h-screen">
  <div class="max-w-4xl mx-auto p-4">

    <!-- Header -->
    <div class="flex items-center justify-between mb-4">
      <div class="flex items-center gap-3">
        <div id="myAvatarPreview" class="w-12 h-12 rounded-full bg-gray-700"></div>
        <div>
          <div id="myName" class="text-lg font-semibold">ConnectNow</div>
          <div id="myStatus" class="text-sm text-gray-400">Checking auth...</div>
        </div>
      </div>
      <div>
        <button id="signOutBtn" class="bg-red-600 px-3 py-1 rounded hidden">Sign out</button>
      </div>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <!-- Users List -->
      <div class="col-span-1 bg-[#0f1724] p-3 rounded-lg shadow">
        <div class="flex items-center justify-between mb-3">
          <h3 class="font-medium">Users</h3>
          <div id="presenceCount" class="text-xs text-gray-400">0 online</div>
        </div>
        <div id="usersList" class="space-y-2 overflow-y-auto max-h-[60vh]"></div>
      </div>

      <!-- Right panel -->
      <div class="col-span-2 bg-[#0f1724] p-4 rounded-lg shadow relative">
        <div id="callStage" class="min-h-[380px] flex flex-col items-center justify-center text-center">
          <div id="idleUI">
            <img src="https://ui-avatars.com/api/?name=ConnectNow&background=111827&color=22c55e" class="w-36 h-36 rounded-full mx-auto mb-4" />
            <h2 class="text-xl font-semibold">Select a user and press the video icon to call</h2>
            <p class="text-sm text-gray-400 mt-2">One-to-one video calls. Audio + Video supported.</p>
          </div>

          <div id="outgoingUI" class="hidden w-full">
            <div class="text-sm text-gray-300">Calling</div>
            <div id="outgoingName" class="text-2xl font-semibold mt-2"></div>
            <div id="outgoingAvatar" class="w-28 h-28 rounded-full bg-gray-600 mx-auto my-3"></div>
            <div class="flex gap-3 justify-center mt-3">
              <button id="cancelOutgoing" class="bg-red-600 px-4 py-2 rounded">Cancel</button>
            </div>
          </div>

          <div id="incomingFull" class="hidden absolute inset-0 bg-black/80 flex items-center justify-center p-6 z-40">
            <div class="bg-[#0b1220] p-6 rounded-lg w-full max-w-md text-center">
              <div id="incomingAvatar" class="w-28 h-28 rounded-full bg-gray-700 mx-auto"></div>
              <div id="incomingName" class="text-xl font-semibold mt-3"></div>
              <div class="text-sm text-gray-400 mt-1">Calling...</div>
              <div class="flex gap-4 justify-center mt-6">
                <button id="declineBtn" class="bg-red-500 px-5 py-2 rounded">Decline</button>
                <button id="acceptBtn" class="bg-green-500 px-5 py-2 rounded">Accept</button>
              </div>
            </div>
          </div>

          <div id="activeCallUI" class="hidden w-full h-full">
            <div class="relative w-full h-[62vh] bg-black rounded-lg overflow-hidden">
              <video id="remoteVideo" autoplay playsinline class="w-full h-full object-cover bg-black"></video>
              <div class="absolute top-4 left-4">
                <div id="remoteName" class="text-white font-semibold bg-black/40 px-3 py-1 rounded"></div>
              </div>
              <div class="absolute bottom-4 left-4">
                <video id="localVideo" autoplay muted playsinline class="small-video"></video>
              </div>
              <div class="absolute bottom-6 right-6 flex gap-3">
                <button id="muteBtn" class="bg-white/10 text-white px-3 py-2 rounded">Mute</button>
                <button id="endBtn" class="bg-red-600 text-white px-4 py-2 rounded">End</button>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <footer class="text-xs text-gray-500 mt-4">Note: Uses STUN + public TURN (testing). For production run a private TURN/coturn server.</footer>
  </div>

  <!-- ringtone -->
  <audio id="ringtone" loop preload="auto">
    <source src="https://actions.google.com/sounds/v1/alarms/phone_alerts_and_ringtones.ogg" type="audio/ogg">
  </audio>

  <!-- enable-sound helper (shown only if autoplay blocked) -->
  <button id="enableSound" class="bg-yellow-400 text-black px-4 py-2 rounded">Enable sound (tap)</button>

  <script type="module">
    // Firebase (modular)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import { getFirestore, collection, doc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";
    import { getDatabase, ref, set, onValue, onDisconnect, push, remove, onChildAdded } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAwB8JWKIRK6Bkat-NdM6OyVAvdrBk5cmM",
      authDomain: "capturedeep-126bf.firebaseapp.com",
      databaseURL: "https://capturedeep-126bf-default-rtdb.firebaseio.com",
      projectId: "capturedeep-126bf",
      storageBucket: "capturedeep-126bf.appspot.com",
      messagingSenderId: "527347157327",
      appId: "1:527347157327:web:d7db7bb6d0fe021547dd3a",
      measurementId: "G-VZEFR8X5BN"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const rdb = getDatabase(app);

    // UI
    const usersList = document.getElementById('usersList');
    const myNameEl = document.getElementById('myName');
    const myAvatarPreview = document.getElementById('myAvatarPreview');
    const myStatus = document.getElementById('myStatus');
    const signOutBtn = document.getElementById('signOutBtn');

    const ringtone = document.getElementById('ringtone');
    const enableSoundBtn = document.getElementById('enableSound');

    const idleUI = document.getElementById('idleUI');
    const outgoingUI = document.getElementById('outgoingUI');
    const outgoingName = document.getElementById('outgoingName');
    const outgoingAvatar = document.getElementById('outgoingAvatar');
    const cancelOutgoing = document.getElementById('cancelOutgoing');

    const incomingFull = document.getElementById('incomingFull');
    const incomingName = document.getElementById('incomingName');
    const incomingAvatar = document.getElementById('incomingAvatar');
    const acceptBtn = document.getElementById('acceptBtn');
    const declineBtn = document.getElementById('declineBtn');

    const activeCallUI = document.getElementById('activeCallUI');
    const remoteName = document.getElementById('remoteName');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const muteBtn = document.getElementById('muteBtn');
    const endBtn = document.getElementById('endBtn');

    // State
    let myUid = null;
    let myProfile = null;
    let pc = null;
    let localStream = null;
    let isMuted = false;
    let currentPeerUid = null;
    let outgoingTarget = null;
    let outgoingTargetName = null;
    let processedCandidates = new Set();
    let pendingCandidates = { caller: [], callee: [] };
    let candidateUnsubs = []; // to store unsubscribe functions
    let userGestureUnlocked = false;

    // ICE config
    const ICE_CONFIG = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'turn:global.relay.metered.ca:443', username: 'public', credential: 'public' },
        { urls: 'turn:relay1.expressturn.com:3478', username: 'efUGnbp1KmJ3b0YO', credential: '6e3K9hK8VWJw9v9B' }
      ]
    };

    // -----------------------
    // Auth check
    // -----------------------
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        location.href = 'auth.html?msg=Please%20login%20to%20connect';
        return;
      }
      myUid = user.uid;
      myStatus.textContent = 'Loading profile...';
      signOutBtn.classList.remove('hidden');

      // load profile from Firestore
      const profDoc = doc(db, 'users', myUid);
      const profSnap = await getDoc(profDoc);
      if (profSnap.exists()) {
        myProfile = profSnap.data();
        myProfile.name = myProfile.name || user.displayName || 'You';
        myProfile.avatarUrl = myProfile.avatarUrl || user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(myProfile.name)}`;
      } else {
        myProfile = { name: user.displayName || 'You', avatarUrl: user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.displayName||'You')}` };
      }
      myNameEl.textContent = myProfile.name;
      myAvatarPreview.style.backgroundImage = `url(${myProfile.avatarUrl})`;
      myAvatarPreview.style.backgroundSize = 'cover';
      myStatus.textContent = 'Online';

      startPresence();
      loadUsers();
      startIncomingListener();
      listenForIncomingCandidates(); // always listen on our candidate paths
      unlockAudioOnFirstGesture();
    });

    signOutBtn.addEventListener('click', async () => {
      await signOut(auth);
    });

    // -----------------------
    // Presence
    // -----------------------
    function startPresence(){
      if (!myUid) return;
      const pRef = ref(rdb, `presence/${myUid}`);
      set(pRef, { name: myProfile.name, online: true, ts: Date.now() }).catch(console.error);
      onDisconnect(pRef).remove().catch(console.error);
    }

    // -----------------------
    // Load users list
    // -----------------------
    let usersUnsub = null;
    function loadUsers(){
      const usersCol = collection(db, 'users');
      if (usersUnsub) usersUnsub();
      usersUnsub = onSnapshot(usersCol, (snap) => {
        usersList.innerHTML = '';
        let onlineCount = 0;
        snap.forEach(docSnap => {
          const uid = docSnap.id;
          const data = docSnap.data();
          const name = data.name || uid;
          const avatar = data.avatarUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}`;
          if (uid === myUid) return;
          const row = document.createElement('div');
          row.className = 'flex items-center justify-between p-2 rounded hover:bg-white/2';
          row.innerHTML = `
            <div class="flex items-center gap-3">
              <img src="${avatar}" class="w-12 h-12 rounded-full object-cover" />
              <div>
                <div class="font-medium">${name}</div>
                <div id="presence-${uid}" class="text-xs text-gray-400">checking...</div>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <button data-uid="${uid}" data-name="${name}" class="callBtn bg-green-600 px-3 py-1 rounded hidden md:inline">ðŸ“¹</button>
              <button data-uid="${uid}" data-name="${name}" class="callBtnMobile bg-green-600 w-10 h-10 rounded-full md:hidden">ðŸ“¹</button>
            </div>
          `;
          usersList.appendChild(row);

          // presence listener
          const presRef = ref(rdb, `presence/${uid}`);
          onValue(presRef, (snapP) => {
            const el = document.getElementById(`presence-${uid}`);
            if (!el) return;
            if (snapP.exists()) {
              el.innerHTML = `<span class="inline-block w-2 h-2 rounded-full bg-green-400 mr-2"></span>Online`;
              onlineCount++;
            } else {
              el.innerHTML = `<span class="inline-block w-2 h-2 rounded-full bg-gray-500 mr-2"></span>Offline`;
            }
            document.getElementById('presenceCount').textContent = onlineCount + ' online';
          });
        });

        document.querySelectorAll('.callBtn, .callBtnMobile').forEach(btn => {
          btn.onclick = () => {
            const targetUid = btn.dataset.uid;
            const targetName = btn.dataset.name;
            startOutgoingCall(targetUid, targetName);
          };
        });
      });
    }

    // -----------------------
    // Incoming calls listener
    // -----------------------
    function startIncomingListener(){
      const myCallRef = ref(rdb, `calls/${myUid}`);
      onValue(myCallRef, (snap) => {
        const data = snap.val();
        if (!data) {
          // cleared
          return;
        }
        if (data.type === 'offer' && data.from) {
          // show incoming
          showIncoming(data);
        } else if (data.type === 'answer' && data.answer && outgoingTarget && data.from === outgoingTarget) {
          // caller receives answer
          const sd = { type: 'answer', sdp: data.answer };
          if (pc && !pc.currentRemoteDescription) {
            pc.setRemoteDescription(sd).then(() => {
              showActiveCallUI(outgoingTargetName || 'Call');
            }).catch(console.error);
          }
        } else if (data.type === 'decline' && data.from) {
          stopOutgoing('declined');
        } else if (data.type === 'end' && data.from) {
          endCallCleanup();
        }
      });
    }

    // -----------------------
    // Candidate listeners (always listen for children added to our candidate slots)
    // -----------------------
    function listenForIncomingCandidates(){
      // caller candidates for me
      const callerRef = ref(rdb, `candidates/${myUid}/caller`);
      const unsub1 = onChildAdded(callerRef, (snap) => {
        const cand = snap.val();
        if (!cand) return;
        if (pc) {
          pc.addIceCandidate(cand).catch(e => console.error('addIce error caller->', e));
        } else {
          pendingCandidates.caller.push(cand);
        }
      });
      candidateUnsubs.push(unsub1);

      // callee candidates for me
      const calleeRef = ref(rdb, `candidates/${myUid}/callee`);
      const unsub2 = onChildAdded(calleeRef, (snap) => {
        const cand = snap.val();
        if (!cand) return;
        if (pc) {
          pc.addIceCandidate(cand).catch(e => console.error('addIce error callee->', e));
        } else {
          pendingCandidates.callee.push(cand);
        }
      });
      candidateUnsubs.push(unsub2);
    }

    // -----------------------
    // Outgoing call (caller)
    // -----------------------
    async function startOutgoingCall(targetUid, targetName){
      if (!myUid) return alert('Not signed in');
      if (pc) return alert('Already in call');

      outgoingTarget = targetUid;
      outgoingTargetName = targetName;

      idleUI.style.display = 'none';
      outgoingUI.style.display = 'block';
      outgoingName.textContent = targetName;
      outgoingAvatar.style.backgroundImage = `url('')`;
      tryPlayRingtone();

      // get local media FIRST
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
      } catch (err) {
        console.error('media error', err);
        alert('Allow camera & mic to make calls');
        stopOutgoing('media-fail');
        return;
      }

      // create pc
      pc = new RTCPeerConnection(ICE_CONFIG);

      // drain pending candidates when ready
      const drainPending = () => {
        pendingCandidates.caller.forEach(c => pc.addIceCandidate(c).catch(console.error));
        pendingCandidates.callee.forEach(c => pc.addIceCandidate(c).catch(console.error));
        pendingCandidates = { caller: [], callee: [] };
      };

      // add local tracks
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      pc.ontrack = (ev) => {
        remoteVideo.srcObject = ev.streams[0];
      };

      // push our ICE candidates to target's 'caller' slot
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          push(ref(rdb, `candidates/${targetUid}/caller`), event.candidate.toJSON()).catch(console.error);
        }
      };

      // create offer AFTER tracks added
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // write offer to target's call node
      await set(ref(rdb, `calls/${targetUid}`), {
        type: 'offer',
        from: myUid,
        name: myProfile.name || '',
        avatar: myProfile.avatarUrl || '',
        offer: offer.sdp,
        ts: Date.now()
      }).catch(console.error);

      // Listen for callee candidates (they will push to our /candidates/{myUid}/callee) handled by onChildAdded listener earlier
      drainPending();
      showActiveCallUI(targetName); // will show active UI once remote tracks arrive and answer is set
    }

    // cancel outgoing
    cancelOutgoing.onclick = async () => {
      if (!outgoingTarget) { stopOutgoing('cancel'); return; }
      try { await set(ref(rdb, `calls/${outgoingTarget}`), null); } catch(e){}
      stopOutgoing('cancelled');
    };

    function stopOutgoing(reason){
      ringtone.pause(); ringtone.currentTime = 0;
      idleUI.style.display = 'block';
      outgoingUI.style.display = 'none';
      outgoingTarget = null;
      outgoingTargetName = null;
      if (pc) { try { pc.close(); } catch(e){} pc = null; }
    }

    // -----------------------
    // Incoming call UI
    // -----------------------
    let currentIncoming = null;
    function showIncoming(data){
      currentIncoming = data;
      incomingName.textContent = data.name || data.from;
      incomingAvatar.style.backgroundImage = `url(${data.avatar||'https://ui-avatars.com/api/?name='+encodeURIComponent(data.name||data.from)})`;
      incomingAvatar.style.backgroundSize = 'cover';
      incomingFull.style.display = 'flex';
      tryPlayRingtone();
    }

    declineBtn.onclick = async () => {
      ringtone.pause(); ringtone.currentTime = 0;
      if (currentIncoming && currentIncoming.from) {
        await set(ref(rdb, `calls/${currentIncoming.from}`), {
          type: 'decline',
          from: myUid,
          ts: Date.now()
        }).catch(console.error);
      }
      await set(ref(rdb, `calls/${myUid}`), null).catch(()=>{});
      incomingFull.style.display = 'none';
      currentIncoming = null;
    };

    // Accept incoming
    acceptBtn.onclick = async () => {
      ringtone.pause(); ringtone.currentTime = 0;
      if (!currentIncoming) return;
      const callerUid = currentIncoming.from;
      currentPeerUid = callerUid;

      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
      } catch (err) {
        console.error('media error', err);
        alert('Allow camera & mic to accept calls');
        return;
      }

      pc = new RTCPeerConnection(ICE_CONFIG);

      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      pc.ontrack = (e) => {
        remoteVideo.srcObject = e.streams[0];
      };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          push(ref(rdb, `candidates/${callerUid}/callee`), event.candidate.toJSON()).catch(console.error);
        }
      };

      // set remote description from offer
      const offer = { type: 'offer', sdp: currentIncoming.offer };
      await pc.setRemoteDescription(offer).catch(console.error);

      // create answer
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // write answer to caller's call node
      await set(ref(rdb, `calls/${callerUid}`), {
        type: 'answer',
        from: myUid,
        answer: answer.sdp,
        ts: Date.now()
      }).catch(console.error);

      // drain any pending candidates
      pendingCandidates.caller.forEach(c => pc.addIceCandidate(c).catch(console.error));
      pendingCandidates.caller = [];
      pendingCandidates.callee.forEach(c => pc.addIceCandidate(c).catch(console.error));
      pendingCandidates.callee = [];

      incomingFull.style.display = 'none';
      showActiveCallUI(currentIncoming.name || currentIncoming.from);
    };

    // -----------------------
    // Show active ui
    // -----------------------
    function showActiveCallUI(peerName){
      idleUI.style.display = 'none';
      outgoingUI.style.display = 'none';
      activeCallUI.style.display = 'block';
      remoteName.textContent = peerName || 'Call';
      if (!currentPeerUid && outgoingTarget) currentPeerUid = outgoingTarget;
    }

    // Mute toggle
    muteBtn.onclick = () => {
      if (!localStream) return;
      isMuted = !isMuted;
      localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
      muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
    };

    // End call
    endBtn.onclick = async () => {
      if (currentPeerUid) {
        await set(ref(rdb, `calls/${currentPeerUid}`), {
          type: 'end',
          from: myUid,
          ts: Date.now()
        }).catch(console.error);
      }
      endCallCleanup();
    };

    function endCallCleanup(){
      ringtone.pause(); ringtone.currentTime = 0;
      if (pc) { try { pc.close(); } catch(e) {} pc = null; }
      if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
      remoteVideo.srcObject = null;
      localVideo.srcObject = null;
      isMuted = false;
      muteBtn.textContent = 'Mute';
      activeCallUI.style.display = 'none';
      incomingFull.style.display = 'none';
      idleUI.style.display = 'block';

      // cleanup RTDB
      if (currentPeerUid) {
        set(ref(rdb, `calls/${currentPeerUid}`), null).catch(()=>{});
        set(ref(rdb, `candidates/${currentPeerUid}`), null).catch(()=>{});
      }
      set(ref(rdb, `calls/${myUid}`), null).catch(()=>{});
      set(ref(rdb, `candidates/${myUid}`), null).catch(()=>{});

      currentPeerUid = null;
      outgoingTarget = null;
      outgoingTargetName = null;
      processedCandidates.clear();
    }

    // -----------------------
    // Unlock audio on first gesture & enableSound button fallback
    // -----------------------
    function unlockAudioOnFirstGesture(){
      const unlock = async () => {
        try {
          await ringtone.play();
          ringtone.pause();
          ringtone.currentTime = 0;
          userGestureUnlocked = true;
          enableSoundBtn.style.display = 'none';
        } catch (e) {
          userGestureUnlocked = false;
          enableSoundBtn.style.display = 'block';
        }
      };
      document.body.addEventListener('click', unlock, { once: true });
      enableSoundBtn.onclick = async () => {
        try {
          await ringtone.play();
          ringtone.pause();
          ringtone.currentTime = 0;
          userGestureUnlocked = true;
          enableSoundBtn.style.display = 'none';
        } catch (e) {
          console.warn('Enable sound failed', e);
        }
      };
    }

    async function tryPlayRingtone(){
      if (!userGestureUnlocked) {
        // try once; browser may block
        try { await ringtone.play(); } catch(e){ enableSoundBtn.style.display = 'block'; }
        return;
      }
      try { await ringtone.play(); } catch(e){ enableSoundBtn.style.display = 'block'; }
    }

    // -----------------------
    // Clean presence & calls on unload
    // -----------------------
    window.addEventListener('beforeunload', async () => {
      if (myUid) {
        await set(ref(rdb, `presence/${myUid}`), null).catch(()=>{});
        await set(ref(rdb, `calls/${myUid}`), null).catch(()=>{});
      }
    });

    // -----------------------
    // Helpers: onChildAdded polyfill fallback if not supported
    // (we already imported onChildAdded above)
    // -----------------------
    // End of script
  </script>
</body>
</html>
