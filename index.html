<!doctype html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ConnectNow â€” 1:1 Video (WebRTC + Firebase)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{
      --bg:#0b0f13; --card:#0f1720; --muted:#94a3b8; --accent:#22c55e;
    }
    body{background:var(--bg); color:#e6eef8; font-family:Inter, system-ui, sans-serif}
    .toast { transition: all .18s ease; }
    .pulse { animation: pulse 1s infinite; }
    @keyframes pulse { 0% { transform: scale(1) } 50% { transform: scale(1.02) } 100% { transform: scale(1) } }
    .small-video { width:110px; height:80px; object-fit:cover; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,.6); }
  </style>
</head>
<body class="min-h-screen">
  <div class="max-w-4xl mx-auto p-4">

    <!-- Header -->
    <div class="flex items-center justify-between mb-4">
      <div class="flex items-center gap-3">
        <div class="w-12 h-12 rounded-full bg-gray-700" id="myAvatarPreview"></div>
        <div>
          <div id="myName" class="text-lg font-semibold">ConnectNow</div>
          <div id="myStatus" class="text-sm text-gray-400">Checking auth...</div>
        </div>
      </div>
      <div>
        <button id="signOutBtn" class="bg-red-600 px-3 py-1 rounded hidden">Sign out</button>
      </div>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <!-- Users List -->
      <div class="col-span-1 bg-[#0f1724] p-3 rounded-lg shadow">
        <div class="flex items-center justify-between mb-3">
          <h3 class="font-medium">Users</h3>
          <div id="presenceCount" class="text-xs text-gray-400">0 online</div>
        </div>
        <div id="usersList" class="space-y-2 overflow-y-auto max-h-[60vh]"></div>
      </div>

      <!-- Right panel: placeholder / instruction -->
      <div class="col-span-2 bg-[#0f1724] p-4 rounded-lg shadow relative">
        <div id="callStage" class="min-h-[380px] flex flex-col items-center justify-center text-center">
          <div id="idleUI">
            <img src="https://ui-avatars.com/api/?name=ConnectNow&background=111827&color=22c55e" class="w-36 h-36 rounded-full mx-auto mb-4" />
            <h2 class="text-xl font-semibold">Select a user and press the video icon to call</h2>
            <p class="text-sm text-gray-400 mt-2">One-to-one video calls. Audio + Video supported.</p>
          </div>

          <!-- Outgoing calling UI -->
          <div id="outgoingUI" class="hidden w-full">
            <div class="text-sm text-gray-300">Calling</div>
            <div id="outgoingName" class="text-2xl font-semibold mt-2"></div>
            <div id="outgoingAvatar" class="w-28 h-28 rounded-full bg-gray-600 mx-auto my-3"></div>
            <div class="flex gap-3 justify-center mt-3">
              <button id="cancelOutgoing" class="bg-red-600 px-4 py-2 rounded">Cancel</button>
            </div>
          </div>

          <!-- Incoming call full-screen style popup -->
          <div id="incomingFull" class="hidden absolute inset-0 bg-black/80 flex items-center justify-center p-6">
            <div class="bg-[#0b1220] p-6 rounded-lg w-full max-w-md text-center">
              <div id="incomingAvatar" class="w-28 h-28 rounded-full bg-gray-700 mx-auto"></div>
              <div id="incomingName" class="text-xl font-semibold mt-3"></div>
              <div class="text-sm text-gray-400 mt-1">Calling...</div>
              <div class="flex gap-4 justify-center mt-6">
                <button id="declineBtn" class="bg-red-500 px-5 py-2 rounded">Decline</button>
                <button id="acceptBtn" class="bg-green-500 px-5 py-2 rounded">Accept</button>
              </div>
            </div>
          </div>

          <!-- Active call UI -->
          <div id="activeCallUI" class="hidden w-full h-full">
            <div class="relative w-full h-[62vh] bg-black rounded-lg overflow-hidden">
              <video id="remoteVideo" autoplay playsinline class="w-full h-full object-cover bg-black"></video>
              <div class="absolute top-4 left-4">
                <div id="remoteName" class="text-white font-semibold bg-black/40 px-3 py-1 rounded"></div>
              </div>

              <div class="absolute bottom-4 left-4">
                <video id="localVideo" autoplay muted playsinline class="small-video"></video>
              </div>

              <div class="absolute bottom-6 right-6 flex gap-3">
                <button id="muteBtn" class="bg-white/10 text-white px-3 py-2 rounded">Mute</button>
                <button id="endBtn" class="bg-red-600 text-white px-4 py-2 rounded">End</button>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <footer class="text-xs text-gray-500 mt-4">Note: Uses STUN + public TURN (testing). For production run a private TURN/coturn server.</footer>
  </div>

  <!-- ringtone -->
  <audio id="ringtone" loop>
    <source src="https://actions.google.com/sounds/v1/alarms/phone_alerts_and_ringtones.ogg" type="audio/ogg">
  </audio>

  <script type="module">
    // =============================
    // Firebase config (from you)
    // =============================
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import { getFirestore, collection, doc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";
    import { getDatabase, ref, set, onValue, onDisconnect, push, remove, update, get, child } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAwB8JWKIRK6Bkat-NdM6OyVAvdrBk5cmM",
      authDomain: "capturedeep-126bf.firebaseapp.com",
      databaseURL: "https://capturedeep-126bf-default-rtdb.firebaseio.com",
      projectId: "capturedeep-126bf",
      storageBucket: "capturedeep-126bf.appspot.com",
      messagingSenderId: "527347157327",
      appId: "1:527347157327:web:d7db7bb6d0fe021547dd3a",
      measurementId: "G-VZEFR8X5BN"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const rdb = getDatabase(app);

    // UI elements
    const usersList = document.getElementById('usersList');
    const presenceCount = document.getElementById('presenceCount');
    const myNameEl = document.getElementById('myName');
    const myAvatarPreview = document.getElementById('myAvatarPreview');
    const myStatus = document.getElementById('myStatus');
    const signOutBtn = document.getElementById('signOutBtn');

    const ringtone = document.getElementById('ringtone');

    const idleUI = document.getElementById('idleUI');
    const outgoingUI = document.getElementById('outgoingUI');
    const outgoingName = document.getElementById('outgoingName');
    const outgoingAvatar = document.getElementById('outgoingAvatar');
    const cancelOutgoing = document.getElementById('cancelOutgoing');

    const incomingFull = document.getElementById('incomingFull');
    const incomingName = document.getElementById('incomingName');
    const incomingAvatar = document.getElementById('incomingAvatar');
    const acceptBtn = document.getElementById('acceptBtn');
    const declineBtn = document.getElementById('declineBtn');

    const activeCallUI = document.getElementById('activeCallUI');
    const remoteName = document.getElementById('remoteName');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const muteBtn = document.getElementById('muteBtn');
    const endBtn = document.getElementById('endBtn');

    // App state
    let myUid = null;
    let myProfile = null; // { name, avatarUrl }
    let usersSnapshotUnsub = null;
    let presenceListeners = {}; // uid -> unsubscribe function (RTDB onValue)
    let pc = null;
    let localStream = null;
    let isMuted = false;
    let currentPeerUid = null; // the other user in call
    let outgoingTarget = null; // uid we called
    // track processed candidate keys to avoid duplicates
    let processedCandidates = new Set();

    // ICE servers (STUN + public TURN for better chance)
    const ICE_CONFIG = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'turn:global.relay.metered.ca:443', username: 'public', credential: 'public' },
        { urls: 'turn:relay1.expressturn.com:3478', username: 'efUGnbp1KmJ3b0YO', credential: '6e3K9hK8VWJw9v9B' }
      ]
    };

    // ------------------------
    // Auth check + redirect if logged out
    // ------------------------
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        // redirect to your auth page (you said you have auth.html)
        location.href = 'auth.html?msg=Please%20login%20to%20connect';
        return;
      }
      myUid = user.uid;
      myStatus.textContent = 'Loading profile...';
      signOutBtn.classList.remove('hidden');

      // load profile from Firestore users/{uid}
      const profDoc = doc(db, 'users', myUid);
      const profSnap = await getDoc(profDoc);
      if (profSnap.exists()) {
        myProfile = profSnap.data();
        myProfile.name = myProfile.name || user.displayName || 'You';
        myProfile.avatarUrl = myProfile.avatarUrl || user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(myProfile.name)}`;
      } else {
        // fallback: use auth values
        myProfile = {
          name: user.displayName || 'You',
          avatarUrl: user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.displayName||'You')}`
        };
      }
      myNameEl.textContent = myProfile.name;
      myAvatarPreview.style.backgroundImage = `url(${myProfile.avatarUrl})`;
      myAvatarPreview.style.backgroundSize = 'cover';

      myStatus.textContent = 'Online';
      startPresence();
      loadUsers();
      startIncomingListener();
      // pre-get media permission so accept is faster (optional)
      // prepareLocalStream(); // don't force â€” we'll get media on call start
    });

    signOutBtn.addEventListener('click', async () => {
      await signOut(auth);
    });

    // ------------------------
    // Presence (Realtime DB)
    // ------------------------
    function startPresence(){
      if (!myUid) return;
      const pRef = ref(rdb, `presence/${myUid}`);
      set(pRef, { name: myProfile.name, online: true, ts: Date.now() }).catch(console.error);
      onDisconnect(pRef).remove().catch(console.error);
    }

    // ------------------------
    // Load users list from Firestore
    // Firestore structure (as per screenshot):
    // users/{uid} => { avatarUrl: "...", createdAt: 1234, name: "Navya Mishra" }
    // ------------------------
    function loadUsers(){
      const usersCol = collection(db, 'users');
      if (usersSnapshotUnsub) usersSnapshotUnsub();
      usersSnapshotUnsub = onSnapshot(usersCol, (snap) => {
        usersList.innerHTML = '';
        let onlineCount = 0;
        snap.forEach(docSnap => {
          const uid = docSnap.id;
          const data = docSnap.data();
          const name = data.name || uid;
          const avatar = data.avatarUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}`;
          // skip self
          if (uid === myUid) return;

          const row = document.createElement('div');
          row.className = 'flex items-center justify-between p-2 rounded hover:bg-white/2';
          row.innerHTML = `
            <div class="flex items-center gap-3">
              <img src="${avatar}" class="w-12 h-12 rounded-full object-cover" />
              <div>
                <div class="font-medium">${name}</div>
                <div id="presence-${uid}" class="text-xs text-gray-400">checking...</div>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <button data-uid="${uid}" data-name="${name}" class="callBtn bg-green-600 px-3 py-1 rounded hidden md:inline">ðŸ“¹</button>
              <button data-uid="${uid}" data-name="${name}" class="callBtnMobile bg-green-600 w-10 h-10 rounded-full md:hidden">ðŸ“¹</button>
            </div>
          `;
          usersList.appendChild(row);

          // listen presence via RTDB
          const presRef = ref(rdb, `presence/${uid}`);
          const off = onValue(presRef, (snapP) => {
            const el = document.getElementById(`presence-${uid}`);
            if (!el) return;
            if (snapP.exists()) {
              el.innerHTML = `<span class="inline-block w-2 h-2 rounded-full bg-green-400 mr-2"></span>Online`;
            } else {
              el.innerHTML = `<span class="inline-block w-2 h-2 rounded-full bg-gray-500 mr-2"></span>Offline`;
            }
          });
          presenceListeners[uid] = off;
        });

        // attach click handlers
        document.querySelectorAll('.callBtn, .callBtnMobile').forEach(btn => {
          btn.onclick = () => {
            const targetUid = btn.dataset.uid;
            const targetName = btn.dataset.name;
            startOutgoingCall(targetUid, targetName);
          };
        });
      });
    }

    // ------------------------
    // Incoming listener for calls (RTDB path: /calls/{myUid})
    // Caller writes to /calls/{targetUid} with { type:'offer', from:myUid, offer: sdp, name, avatar }
    // Callee will write answer to /calls/{callerUid} with type:'answer', answer:sdp ...
    // ------------------------
    let incomingListenerOff = null;
    function startIncomingListener(){
      const myCallRef = ref(rdb, `calls/${myUid}`);
      incomingListenerOff = onValue(myCallRef, async (snap) => {
        const data = snap.val();
        if (!data) {
          // nothing
          return;
        }
        if (data.type === 'offer' && data.from) {
          // incoming call
          showIncoming(data);
        } else if (data.type === 'answer' && data.answer && outgoingTarget && data.from === outgoingTarget) {
          // caller receives answer
          // setRemoteDescription
          const sd = { type: 'answer', sdp: data.answer };
          if (pc && !pc.currentRemoteDescription) {
            await pc.setRemoteDescription(new RTCSessionDescription(sd)).catch(console.error);
            // caller connected
            showActiveCallUI(outgoingTargetName || 'Call');
          }
        } else if (data.type === 'decline' && data.from) {
          // callee declined our outgoing call
          stopOutgoing('declined');
        } else if (data.type === 'end' && data.from) {
          // peer ended the call
          endCallCleanup();
        }
      });
    }

    // ------------------------
    // Outgoing call (caller)
    // ------------------------
    let outgoingTargetName = null;
    async function startOutgoingCall(targetUid, targetName){
      if (!myUid) return alert('Not signed in');
      if (pc) return alert('Already in call');

      outgoingTarget = targetUid;
      outgoingTargetName = targetName;

      // show outgoing UI
      idleUI.style.display = 'none';
      outgoingUI.style.display = 'block';
      outgoingName.textContent = targetName;
      outgoingAvatar.style.backgroundImage = ''; // can set fetch avatar from users col if needed
      ringtone.play().catch(()=>{});

      // Ensure we have local media
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
      } catch (err) {
        console.error('media error', err);
        alert('Allow camera & mic to make calls');
        stopOutgoing('media-fail');
        return;
      }

      // create peer connection
      pc = new RTCPeerConnection(ICE_CONFIG);

      // add local tracks
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      // on remote track
      pc.ontrack = (ev) => {
        remoteVideo.srcObject = ev.streams[0];
      };

      // ICE candidate handler: push to candidates/<targetUid>/caller
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          const candRef = ref(rdb, `candidates/${targetUid}/caller`);
          push(candRef, event.candidate.toJSON()).catch(console.error);
        }
      };

      // create offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // write offer to /calls/{targetUid}
      set(ref(rdb, `calls/${targetUid}`), {
        type: 'offer',
        from: myUid,
        name: myProfile.name || '',
        avatar: myProfile.avatarUrl || '',
        offer: offer.sdp,
        ts: Date.now()
      }).catch(console.error);

      // listen for callee candidates at candidates/<myUid>/callee
      const calleeCandidatesRef = ref(rdb, `candidates/${myUid}/callee`);
      onValue(calleeCandidatesRef, (snap) => {
        const val = snap.val();
        if (!val) return;
        Object.keys(val).forEach(k => {
          if (processedCandidates.has(k)) return;
          processedCandidates.add(k);
          const cand = val[k];
          pc.addIceCandidate(new RTCIceCandidate(cand)).catch(console.error);
        });
      });

      // listen for answer handled in startIncomingListener (onValue for /calls/myUid)
    }

    // cancel outgoing
    cancelOutgoing.onclick = async () => {
      if (!outgoingTarget) { stopOutgoing('cancel'); return; }
      // notify the callee that we cancelled (remove call node)
      try { await set(ref(rdb, `calls/${outgoingTarget}`), null); } catch(e){}
      stopOutgoing('cancelled');
    };

    function stopOutgoing(reason){
      ringtone.pause();
      ringtone.currentTime = 0;
      idleUI.style.display = 'block';
      outgoingUI.style.display = 'none';
      outgoingTarget = null;
      outgoingTargetName = null;
      if (pc) { try{ pc.close(); } catch(e){} pc = null; }
      // cleanup candidates nodes relating to this call (best-effort)
    }

    // ------------------------
    // Show incoming UI and accept/decline handlers
    // ------------------------
    let currentIncoming = null; // data of incoming call
    function showIncoming(data){
      currentIncoming = data;
      incomingName.textContent = data.name || data.from;
      incomingAvatar.style.backgroundImage = `url(${data.avatar||'https://ui-avatars.com/api/?name='+encodeURIComponent(data.name||data.from)})`;
      incomingAvatar.style.backgroundSize = 'cover';
      incomingFull.style.display = 'flex';
      ringtone.play().catch(()=>{});
    }

    declineBtn.onclick = async () => {
      ringtone.pause(); ringtone.currentTime = 0;
      // notify caller (write type:'decline' to /calls/{callerUid})
      if (currentIncoming && currentIncoming.from) {
        await set(ref(rdb, `calls/${currentIncoming.from}`), {
          type: 'decline',
          from: myUid,
          ts: Date.now()
        }).catch(console.error);
      }
      // remove our incoming node
      await set(ref(rdb, `calls/${myUid}`), null).catch(()=>{});
      incomingFull.style.display = 'none';
      currentIncoming = null;
    };

    // Accept incoming call
    acceptBtn.onclick = async () => {
      ringtone.pause(); ringtone.currentTime = 0;
      if (!currentIncoming) return;
      const callerUid = currentIncoming.from;
      currentPeerUid = callerUid;

      // prepare local media
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
      } catch (err) {
        console.error('media error', err);
        alert('Allow camera & mic to accept calls');
        return;
      }

      // create pc
      pc = new RTCPeerConnection(ICE_CONFIG);
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      pc.ontrack = (e) => {
        remoteVideo.srcObject = e.streams[0];
      };

      // send our ICE candidates to candidates/<callerUid>/callee
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          const candRef = ref(rdb, `candidates/${callerUid}/callee`);
          push(candRef, event.candidate.toJSON()).catch(console.error);
        }
      };

      // set remote description from offer
      const offer = { type: 'offer', sdp: currentIncoming.offer };
      await pc.setRemoteDescription(new RTCSessionDescription(offer)).catch(console.error);

      // create answer
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // write answer to /calls/{callerUid}
      await set(ref(rdb, `calls/${callerUid}`), {
        type: 'answer',
        from: myUid,
        answer: answer.sdp,
        ts: Date.now()
      }).catch(console.error);

      // listen for caller's ICE candidates at candidates/<myUid>/caller (caller pushed there)
      const callerCandidatesRef = ref(rdb, `candidates/${myUid}/caller`);
      onValue(callerCandidatesRef, (snap) => {
        const val = snap.val();
        if (!val) return;
        Object.keys(val).forEach(k => {
          if (processedCandidates.has(k)) return;
          processedCandidates.add(k);
          const cand = val[k];
          pc.addIceCandidate(new RTCIceCandidate(cand)).catch(console.error);
        });
      });

      // show active UI
      incomingFull.style.display = 'none';
      showActiveCallUI(currentIncoming.name || currentIncoming.from);
    };

    // ------------------------
    // Show active call UI
    // ------------------------
    function showActiveCallUI(peerName){
      idleUI.style.display = 'none';
      outgoingUI.style.display = 'none';
      activeCallUI.style.display = 'block';
      remoteName.textContent = peerName || 'Call';
      // save that we are in call (optionally)
      // set currentPeerUid etc; for caller currentPeerUid = outgoingTarget
      if (!currentPeerUid && outgoingTarget) currentPeerUid = outgoingTarget;
    }

    // Mute toggle
    muteBtn.onclick = () => {
      if (!localStream) return;
      isMuted = !isMuted;
      localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
      muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
    };

    // End call
    endBtn.onclick = async () => {
      // notify peer
      if (currentPeerUid) {
        await set(ref(rdb, `calls/${currentPeerUid}`), {
          type: 'end',
          from: myUid,
          ts: Date.now()
        }).catch(console.error);
      }
      endCallCleanup();
    };

    function endCallCleanup(){
      // stop ringtone
      ringtone.pause(); ringtone.currentTime = 0;

      // stop pc & streams
      if (pc) { try { pc.getSenders().forEach(s => pc.removeTrack && pc.removeTrack(s)); } catch(e){} try{ pc.close(); }catch(e){} pc = null; }
      if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
      remoteVideo.srcObject = null;
      localVideo.srcObject = null;
      isMuted = false;
      muteBtn.textContent = 'Mute';

      // hide active UI, return to idle
      activeCallUI.style.display = 'none';
      incomingFull.style.display = 'none';
      idleUI.style.display = 'block';

      // cleanup RTDB nodes: remove /calls/<myUid> and /calls/<peerUid> candidates (best effort)
      if (currentPeerUid) {
        set(ref(rdb, `calls/${currentPeerUid}`), null).catch(()=>{});
        set(ref(rdb, `candidates/${currentPeerUid}`), null).catch(()=>{});
      }
      set(ref(rdb, `calls/${myUid}`), null).catch(()=>{});
      set(ref(rdb, `candidates/${myUid}`), null).catch(()=>{});

      currentPeerUid = null;
      outgoingTarget = null;
    }

    // ------------------------
    // Small helper: when page unload remove presence and optionally end call
    // ------------------------
    window.addEventListener('beforeunload', async () => {
      if (myUid) {
        await set(ref(rdb, `presence/${myUid}`), null).catch(()=>{});
        await set(ref(rdb, `calls/${myUid}`), null).catch(()=>{});
      }
    });

    // ------------------------
    // Done. Notes:
    // - This uses Firestore collection 'users' (docs keyed by uid) for profile details.
    //   Example doc structure (from screenshot):
    //    users/{uid} => { avatarUrl: "...", createdAt: 1736881063364, name: "Navya Mishra" }
    // - Presence stored in RTDB at /presence/{uid}
    // - Signaling stored in RTDB at /calls/{uid} (simple one-slot per-user)
    // - ICE candidates in RTDB at /candidates/{uid}/caller or /candidates/{uid}/callee
    // - Ringtone used from actions.google (included above)
    //
    // Limitations & behaviour:
    // - Single pending call per user (calls/{uid} overwritten per new call)
    // - Uses public TURN servers for higher connection chance (testing only)
    // - For production run your own TURN/coturn and secure Firebase rules
    // ------------------------

  </script>
</body>
</html>
